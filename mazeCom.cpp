// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mazeCom.hpp"

// MazeComType
// 

MazeComType::
MazeComType ()
: ::xml_schema::string ()
{
}

MazeComType::
MazeComType (value v)
: ::xml_schema::string (_xsd_MazeComType_literals_[v])
{
}

MazeComType::
MazeComType (const char* v)
: ::xml_schema::string (v)
{
}

MazeComType::
MazeComType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

MazeComType::
MazeComType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

MazeComType::
MazeComType (const MazeComType& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

MazeComType& MazeComType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_MazeComType_literals_[v]);

  return *this;
}


// treasureType
// 

treasureType::
treasureType ()
: ::xml_schema::string ()
{
}

treasureType::
treasureType (value v)
: ::xml_schema::string (_xsd_treasureType_literals_[v])
{
}

treasureType::
treasureType (const char* v)
: ::xml_schema::string (v)
{
}

treasureType::
treasureType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

treasureType::
treasureType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

treasureType::
treasureType (const treasureType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

treasureType& treasureType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_treasureType_literals_[v]);

  return *this;
}


// ErrorType
// 

ErrorType::
ErrorType ()
: ::xml_schema::string ()
{
}

ErrorType::
ErrorType (value v)
: ::xml_schema::string (_xsd_ErrorType_literals_[v])
{
}

ErrorType::
ErrorType (const char* v)
: ::xml_schema::string (v)
{
}

ErrorType::
ErrorType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ErrorType::
ErrorType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ErrorType::
ErrorType (const ErrorType& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ErrorType& ErrorType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ErrorType_literals_[v]);

  return *this;
}


// cardType
// 

const cardType::openings_type& cardType::
openings () const
{
  return this->openings_.get ();
}

cardType::openings_type& cardType::
openings ()
{
  return this->openings_.get ();
}

void cardType::
openings (const openings_type& x)
{
  this->openings_.set (x);
}

void cardType::
openings (::std::auto_ptr< openings_type > x)
{
  this->openings_.set (x);
}

const cardType::pin_type& cardType::
pin () const
{
  return this->pin_.get ();
}

cardType::pin_type& cardType::
pin ()
{
  return this->pin_.get ();
}

void cardType::
pin (const pin_type& x)
{
  this->pin_.set (x);
}

void cardType::
pin (::std::auto_ptr< pin_type > x)
{
  this->pin_.set (x);
}

const cardType::treasure_optional& cardType::
treasure () const
{
  return this->treasure_;
}

cardType::treasure_optional& cardType::
treasure ()
{
  return this->treasure_;
}

void cardType::
treasure (const treasure_type& x)
{
  this->treasure_.set (x);
}

void cardType::
treasure (const treasure_optional& x)
{
  this->treasure_ = x;
}

void cardType::
treasure (::std::auto_ptr< treasure_type > x)
{
  this->treasure_.set (x);
}


// boardType
// 

const boardType::row_sequence& boardType::
row () const
{
  return this->row_;
}

boardType::row_sequence& boardType::
row ()
{
  return this->row_;
}

void boardType::
row (const row_sequence& s)
{
  this->row_ = s;
}

const boardType::shiftCard_type& boardType::
shiftCard () const
{
  return this->shiftCard_.get ();
}

boardType::shiftCard_type& boardType::
shiftCard ()
{
  return this->shiftCard_.get ();
}

void boardType::
shiftCard (const shiftCard_type& x)
{
  this->shiftCard_.set (x);
}

void boardType::
shiftCard (::std::auto_ptr< shiftCard_type > x)
{
  this->shiftCard_.set (x);
}

const boardType::forbidden_optional& boardType::
forbidden () const
{
  return this->forbidden_;
}

boardType::forbidden_optional& boardType::
forbidden ()
{
  return this->forbidden_;
}

void boardType::
forbidden (const forbidden_type& x)
{
  this->forbidden_.set (x);
}

void boardType::
forbidden (const forbidden_optional& x)
{
  this->forbidden_ = x;
}

void boardType::
forbidden (::std::auto_ptr< forbidden_type > x)
{
  this->forbidden_.set (x);
}


// positionType
// 

const positionType::row_type& positionType::
row () const
{
  return this->row_.get ();
}

positionType::row_type& positionType::
row ()
{
  return this->row_.get ();
}

void positionType::
row (const row_type& x)
{
  this->row_.set (x);
}

const positionType::col_type& positionType::
col () const
{
  return this->col_.get ();
}

positionType::col_type& positionType::
col ()
{
  return this->col_.get ();
}

void positionType::
col (const col_type& x)
{
  this->col_.set (x);
}


// LoginMessageType
// 

const LoginMessageType::name_type& LoginMessageType::
name () const
{
  return this->name_.get ();
}

LoginMessageType::name_type& LoginMessageType::
name ()
{
  return this->name_.get ();
}

void LoginMessageType::
name (const name_type& x)
{
  this->name_.set (x);
}

void LoginMessageType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// LoginReplyMessageType
// 

const LoginReplyMessageType::newID_type& LoginReplyMessageType::
newID () const
{
  return this->newID_.get ();
}

LoginReplyMessageType::newID_type& LoginReplyMessageType::
newID ()
{
  return this->newID_.get ();
}

void LoginReplyMessageType::
newID (const newID_type& x)
{
  this->newID_.set (x);
}


// AwaitMoveMessageType
// 

const AwaitMoveMessageType::board_type& AwaitMoveMessageType::
board () const
{
  return this->board_.get ();
}

AwaitMoveMessageType::board_type& AwaitMoveMessageType::
board ()
{
  return this->board_.get ();
}

void AwaitMoveMessageType::
board (const board_type& x)
{
  this->board_.set (x);
}

void AwaitMoveMessageType::
board (::std::auto_ptr< board_type > x)
{
  this->board_.set (x);
}

const AwaitMoveMessageType::treasuresToGo_sequence& AwaitMoveMessageType::
treasuresToGo () const
{
  return this->treasuresToGo_;
}

AwaitMoveMessageType::treasuresToGo_sequence& AwaitMoveMessageType::
treasuresToGo ()
{
  return this->treasuresToGo_;
}

void AwaitMoveMessageType::
treasuresToGo (const treasuresToGo_sequence& s)
{
  this->treasuresToGo_ = s;
}

const AwaitMoveMessageType::treasure_type& AwaitMoveMessageType::
treasure () const
{
  return this->treasure_.get ();
}

AwaitMoveMessageType::treasure_type& AwaitMoveMessageType::
treasure ()
{
  return this->treasure_.get ();
}

void AwaitMoveMessageType::
treasure (const treasure_type& x)
{
  this->treasure_.set (x);
}

void AwaitMoveMessageType::
treasure (::std::auto_ptr< treasure_type > x)
{
  this->treasure_.set (x);
}


// TreasuresToGoType
// 

const TreasuresToGoType::player_type& TreasuresToGoType::
player () const
{
  return this->player_.get ();
}

TreasuresToGoType::player_type& TreasuresToGoType::
player ()
{
  return this->player_.get ();
}

void TreasuresToGoType::
player (const player_type& x)
{
  this->player_.set (x);
}

const TreasuresToGoType::treasures_type& TreasuresToGoType::
treasures () const
{
  return this->treasures_.get ();
}

TreasuresToGoType::treasures_type& TreasuresToGoType::
treasures ()
{
  return this->treasures_.get ();
}

void TreasuresToGoType::
treasures (const treasures_type& x)
{
  this->treasures_.set (x);
}


// MoveMessageType
// 

const MoveMessageType::shiftPosition_type& MoveMessageType::
shiftPosition () const
{
  return this->shiftPosition_.get ();
}

MoveMessageType::shiftPosition_type& MoveMessageType::
shiftPosition ()
{
  return this->shiftPosition_.get ();
}

void MoveMessageType::
shiftPosition (const shiftPosition_type& x)
{
  this->shiftPosition_.set (x);
}

void MoveMessageType::
shiftPosition (::std::auto_ptr< shiftPosition_type > x)
{
  this->shiftPosition_.set (x);
}

const MoveMessageType::newPinPos_type& MoveMessageType::
newPinPos () const
{
  return this->newPinPos_.get ();
}

MoveMessageType::newPinPos_type& MoveMessageType::
newPinPos ()
{
  return this->newPinPos_.get ();
}

void MoveMessageType::
newPinPos (const newPinPos_type& x)
{
  this->newPinPos_.set (x);
}

void MoveMessageType::
newPinPos (::std::auto_ptr< newPinPos_type > x)
{
  this->newPinPos_.set (x);
}

const MoveMessageType::shiftCard_type& MoveMessageType::
shiftCard () const
{
  return this->shiftCard_.get ();
}

MoveMessageType::shiftCard_type& MoveMessageType::
shiftCard ()
{
  return this->shiftCard_.get ();
}

void MoveMessageType::
shiftCard (const shiftCard_type& x)
{
  this->shiftCard_.set (x);
}

void MoveMessageType::
shiftCard (::std::auto_ptr< shiftCard_type > x)
{
  this->shiftCard_.set (x);
}


// AcceptMessageType
// 

const AcceptMessageType::accept_type& AcceptMessageType::
accept () const
{
  return this->accept_.get ();
}

AcceptMessageType::accept_type& AcceptMessageType::
accept ()
{
  return this->accept_.get ();
}

void AcceptMessageType::
accept (const accept_type& x)
{
  this->accept_.set (x);
}

const AcceptMessageType::errorCode_type& AcceptMessageType::
errorCode () const
{
  return this->errorCode_.get ();
}

AcceptMessageType::errorCode_type& AcceptMessageType::
errorCode ()
{
  return this->errorCode_.get ();
}

void AcceptMessageType::
errorCode (const errorCode_type& x)
{
  this->errorCode_.set (x);
}

void AcceptMessageType::
errorCode (::std::auto_ptr< errorCode_type > x)
{
  this->errorCode_.set (x);
}


// WinMessageType
// 

const WinMessageType::board_type& WinMessageType::
board () const
{
  return this->board_.get ();
}

WinMessageType::board_type& WinMessageType::
board ()
{
  return this->board_.get ();
}

void WinMessageType::
board (const board_type& x)
{
  this->board_.set (x);
}

void WinMessageType::
board (::std::auto_ptr< board_type > x)
{
  this->board_.set (x);
}

const WinMessageType::winner_type& WinMessageType::
winner () const
{
  return this->winner_.get ();
}

WinMessageType::winner_type& WinMessageType::
winner ()
{
  return this->winner_.get ();
}

void WinMessageType::
winner (const winner_type& x)
{
  this->winner_.set (x);
}

void WinMessageType::
winner (::std::auto_ptr< winner_type > x)
{
  this->winner_.set (x);
}


// DisconnectMessageType
// 

const DisconnectMessageType::name_type& DisconnectMessageType::
name () const
{
  return this->name_.get ();
}

DisconnectMessageType::name_type& DisconnectMessageType::
name ()
{
  return this->name_.get ();
}

void DisconnectMessageType::
name (const name_type& x)
{
  this->name_.set (x);
}

void DisconnectMessageType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const DisconnectMessageType::erroCode_type& DisconnectMessageType::
erroCode () const
{
  return this->erroCode_.get ();
}

DisconnectMessageType::erroCode_type& DisconnectMessageType::
erroCode ()
{
  return this->erroCode_.get ();
}

void DisconnectMessageType::
erroCode (const erroCode_type& x)
{
  this->erroCode_.set (x);
}

void DisconnectMessageType::
erroCode (::std::auto_ptr< erroCode_type > x)
{
  this->erroCode_.set (x);
}


// openings
// 

const openings::top_type& openings::
top () const
{
  return this->top_.get ();
}

openings::top_type& openings::
top ()
{
  return this->top_.get ();
}

void openings::
top (const top_type& x)
{
  this->top_.set (x);
}

const openings::bottom_type& openings::
bottom () const
{
  return this->bottom_.get ();
}

openings::bottom_type& openings::
bottom ()
{
  return this->bottom_.get ();
}

void openings::
bottom (const bottom_type& x)
{
  this->bottom_.set (x);
}

const openings::left_type& openings::
left () const
{
  return this->left_.get ();
}

openings::left_type& openings::
left ()
{
  return this->left_.get ();
}

void openings::
left (const left_type& x)
{
  this->left_.set (x);
}

const openings::right_type& openings::
right () const
{
  return this->right_.get ();
}

openings::right_type& openings::
right ()
{
  return this->right_.get ();
}

void openings::
right (const right_type& x)
{
  this->right_.set (x);
}


// pin
// 

const pin::playerID_sequence& pin::
playerID () const
{
  return this->playerID_;
}

pin::playerID_sequence& pin::
playerID ()
{
  return this->playerID_;
}

void pin::
playerID (const playerID_sequence& s)
{
  this->playerID_ = s;
}


// row
// 

const row::col_sequence& row::
col () const
{
  return this->col_;
}

row::col_sequence& row::
col ()
{
  return this->col_;
}

void row::
col (const col_sequence& s)
{
  this->col_ = s;
}


// MazeCom
// 

const MazeCom::LoginMessage_optional& MazeCom::
LoginMessage () const
{
  return this->LoginMessage_;
}

MazeCom::LoginMessage_optional& MazeCom::
LoginMessage ()
{
  return this->LoginMessage_;
}

void MazeCom::
LoginMessage (const LoginMessage_type& x)
{
  this->LoginMessage_.set (x);
}

void MazeCom::
LoginMessage (const LoginMessage_optional& x)
{
  this->LoginMessage_ = x;
}

void MazeCom::
LoginMessage (::std::auto_ptr< LoginMessage_type > x)
{
  this->LoginMessage_.set (x);
}

const MazeCom::LoginReplyMessage_optional& MazeCom::
LoginReplyMessage () const
{
  return this->LoginReplyMessage_;
}

MazeCom::LoginReplyMessage_optional& MazeCom::
LoginReplyMessage ()
{
  return this->LoginReplyMessage_;
}

void MazeCom::
LoginReplyMessage (const LoginReplyMessage_type& x)
{
  this->LoginReplyMessage_.set (x);
}

void MazeCom::
LoginReplyMessage (const LoginReplyMessage_optional& x)
{
  this->LoginReplyMessage_ = x;
}

void MazeCom::
LoginReplyMessage (::std::auto_ptr< LoginReplyMessage_type > x)
{
  this->LoginReplyMessage_.set (x);
}

const MazeCom::AwaitMoveMessage_optional& MazeCom::
AwaitMoveMessage () const
{
  return this->AwaitMoveMessage_;
}

MazeCom::AwaitMoveMessage_optional& MazeCom::
AwaitMoveMessage ()
{
  return this->AwaitMoveMessage_;
}

void MazeCom::
AwaitMoveMessage (const AwaitMoveMessage_type& x)
{
  this->AwaitMoveMessage_.set (x);
}

void MazeCom::
AwaitMoveMessage (const AwaitMoveMessage_optional& x)
{
  this->AwaitMoveMessage_ = x;
}

void MazeCom::
AwaitMoveMessage (::std::auto_ptr< AwaitMoveMessage_type > x)
{
  this->AwaitMoveMessage_.set (x);
}

const MazeCom::MoveMessage_optional& MazeCom::
MoveMessage () const
{
  return this->MoveMessage_;
}

MazeCom::MoveMessage_optional& MazeCom::
MoveMessage ()
{
  return this->MoveMessage_;
}

void MazeCom::
MoveMessage (const MoveMessage_type& x)
{
  this->MoveMessage_.set (x);
}

void MazeCom::
MoveMessage (const MoveMessage_optional& x)
{
  this->MoveMessage_ = x;
}

void MazeCom::
MoveMessage (::std::auto_ptr< MoveMessage_type > x)
{
  this->MoveMessage_.set (x);
}

const MazeCom::AcceptMessage_optional& MazeCom::
AcceptMessage () const
{
  return this->AcceptMessage_;
}

MazeCom::AcceptMessage_optional& MazeCom::
AcceptMessage ()
{
  return this->AcceptMessage_;
}

void MazeCom::
AcceptMessage (const AcceptMessage_type& x)
{
  this->AcceptMessage_.set (x);
}

void MazeCom::
AcceptMessage (const AcceptMessage_optional& x)
{
  this->AcceptMessage_ = x;
}

void MazeCom::
AcceptMessage (::std::auto_ptr< AcceptMessage_type > x)
{
  this->AcceptMessage_.set (x);
}

const MazeCom::WinMessage_optional& MazeCom::
WinMessage () const
{
  return this->WinMessage_;
}

MazeCom::WinMessage_optional& MazeCom::
WinMessage ()
{
  return this->WinMessage_;
}

void MazeCom::
WinMessage (const WinMessage_type& x)
{
  this->WinMessage_.set (x);
}

void MazeCom::
WinMessage (const WinMessage_optional& x)
{
  this->WinMessage_ = x;
}

void MazeCom::
WinMessage (::std::auto_ptr< WinMessage_type > x)
{
  this->WinMessage_.set (x);
}

const MazeCom::DisconnectMessage_optional& MazeCom::
DisconnectMessage () const
{
  return this->DisconnectMessage_;
}

MazeCom::DisconnectMessage_optional& MazeCom::
DisconnectMessage ()
{
  return this->DisconnectMessage_;
}

void MazeCom::
DisconnectMessage (const DisconnectMessage_type& x)
{
  this->DisconnectMessage_.set (x);
}

void MazeCom::
DisconnectMessage (const DisconnectMessage_optional& x)
{
  this->DisconnectMessage_ = x;
}

void MazeCom::
DisconnectMessage (::std::auto_ptr< DisconnectMessage_type > x)
{
  this->DisconnectMessage_.set (x);
}

const MazeCom::mcType_type& MazeCom::
mcType () const
{
  return this->mcType_.get ();
}

MazeCom::mcType_type& MazeCom::
mcType ()
{
  return this->mcType_.get ();
}

void MazeCom::
mcType (const mcType_type& x)
{
  this->mcType_.set (x);
}

void MazeCom::
mcType (::std::auto_ptr< mcType_type > x)
{
  this->mcType_.set (x);
}

const MazeCom::id_type& MazeCom::
id () const
{
  return this->id_.get ();
}

MazeCom::id_type& MazeCom::
id ()
{
  return this->id_.get ();
}

void MazeCom::
id (const id_type& x)
{
  this->id_.set (x);
}


// winner
// 

const winner::id_type& winner::
id () const
{
  return this->id_.get ();
}

winner::id_type& winner::
id ()
{
  return this->id_.get ();
}

void winner::
id (const id_type& x)
{
  this->id_.set (x);
}


#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MazeComType
//

MazeComType::
MazeComType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_MazeComType_convert ();
}

MazeComType::
MazeComType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_MazeComType_convert ();
}

MazeComType::
MazeComType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_MazeComType_convert ();
}

MazeComType* MazeComType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MazeComType (*this, f, c);
}

MazeComType::value MazeComType::
_xsd_MazeComType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MazeComType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_MazeComType_indexes_,
                    _xsd_MazeComType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_MazeComType_indexes_ + 7 || _xsd_MazeComType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const MazeComType::
_xsd_MazeComType_literals_[7] =
{
  "LOGIN",
  "LOGINREPLY",
  "AWAITMOVE",
  "MOVE",
  "ACCEPT",
  "WIN",
  "DISCONNECT"
};

const MazeComType::value MazeComType::
_xsd_MazeComType_indexes_[7] =
{
  ::MazeComType::ACCEPT,
  ::MazeComType::AWAITMOVE,
  ::MazeComType::DISCONNECT,
  ::MazeComType::LOGIN,
  ::MazeComType::LOGINREPLY,
  ::MazeComType::MOVE,
  ::MazeComType::WIN
};

// treasureType
//

treasureType::
treasureType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_treasureType_convert ();
}

treasureType::
treasureType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_treasureType_convert ();
}

treasureType::
treasureType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_treasureType_convert ();
}

treasureType* treasureType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class treasureType (*this, f, c);
}

treasureType::value treasureType::
_xsd_treasureType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_treasureType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_treasureType_indexes_,
                    _xsd_treasureType_indexes_ + 28,
                    *this,
                    c));

  if (i == _xsd_treasureType_indexes_ + 28 || _xsd_treasureType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const treasureType::
_xsd_treasureType_literals_[28] =
{
  "Start01",
  "Start02",
  "Start03",
  "Start04",
  "sym01",
  "sym02",
  "sym03",
  "sym04",
  "sym05",
  "sym06",
  "sym07",
  "sym08",
  "sym09",
  "sym10",
  "sym11",
  "sym12",
  "sym13",
  "sym14",
  "sym15",
  "sym16",
  "sym17",
  "sym18",
  "sym19",
  "sym20",
  "sym21",
  "sym22",
  "sym23",
  "sym24"
};

const treasureType::value treasureType::
_xsd_treasureType_indexes_[28] =
{
  ::treasureType::Start01,
  ::treasureType::Start02,
  ::treasureType::Start03,
  ::treasureType::Start04,
  ::treasureType::sym01,
  ::treasureType::sym02,
  ::treasureType::sym03,
  ::treasureType::sym04,
  ::treasureType::sym05,
  ::treasureType::sym06,
  ::treasureType::sym07,
  ::treasureType::sym08,
  ::treasureType::sym09,
  ::treasureType::sym10,
  ::treasureType::sym11,
  ::treasureType::sym12,
  ::treasureType::sym13,
  ::treasureType::sym14,
  ::treasureType::sym15,
  ::treasureType::sym16,
  ::treasureType::sym17,
  ::treasureType::sym18,
  ::treasureType::sym19,
  ::treasureType::sym20,
  ::treasureType::sym21,
  ::treasureType::sym22,
  ::treasureType::sym23,
  ::treasureType::sym24
};

// ErrorType
//

ErrorType::
ErrorType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ErrorType_convert ();
}

ErrorType::
ErrorType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ErrorType_convert ();
}

ErrorType::
ErrorType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ErrorType_convert ();
}

ErrorType* ErrorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ErrorType (*this, f, c);
}

ErrorType::value ErrorType::
_xsd_ErrorType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ErrorType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ErrorType_indexes_,
                    _xsd_ErrorType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_ErrorType_indexes_ + 7 || _xsd_ErrorType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ErrorType::
_xsd_ErrorType_literals_[7] =
{
  "NOERROR",
  "ERROR",
  "AWAIT_LOGIN",
  "AWAIT_MOVE",
  "ILLEGAL_MOVE",
  "TIMEOUT",
  "TOO_MANY_TRIES"
};

const ErrorType::value ErrorType::
_xsd_ErrorType_indexes_[7] =
{
  ::ErrorType::AWAIT_LOGIN,
  ::ErrorType::AWAIT_MOVE,
  ::ErrorType::ERROR,
  ::ErrorType::ILLEGAL_MOVE,
  ::ErrorType::NOERROR,
  ::ErrorType::TIMEOUT,
  ::ErrorType::TOO_MANY_TRIES
};

// cardType
//

cardType::
cardType ()
: ::xml_schema::type (),
  openings_ (::xml_schema::flags (), this),
  pin_ (::xml_schema::flags (), this),
  treasure_ (::xml_schema::flags (), this)
{
}

cardType::
cardType (const openings_type& openings,
          const pin_type& pin)
: ::xml_schema::type (),
  openings_ (openings, ::xml_schema::flags (), this),
  pin_ (pin, ::xml_schema::flags (), this),
  treasure_ (::xml_schema::flags (), this)
{
}

cardType::
cardType (::std::auto_ptr< openings_type >& openings,
          ::std::auto_ptr< pin_type >& pin)
: ::xml_schema::type (),
  openings_ (openings, ::xml_schema::flags (), this),
  pin_ (pin, ::xml_schema::flags (), this),
  treasure_ (::xml_schema::flags (), this)
{
}

cardType::
cardType (const cardType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  openings_ (x.openings_, f, this),
  pin_ (x.pin_, f, this),
  treasure_ (x.treasure_, f, this)
{
}

cardType::
cardType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  openings_ (f, this),
  pin_ (f, this),
  treasure_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void cardType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // openings
    //
    if (n.name () == "openings" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< openings_type > r (
        openings_traits::create (i, f, this));

      if (!openings_.present ())
      {
        this->openings_.set (r);
        continue;
      }
    }

    // pin
    //
    if (n.name () == "pin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< pin_type > r (
        pin_traits::create (i, f, this));

      if (!pin_.present ())
      {
        this->pin_.set (r);
        continue;
      }
    }

    // treasure
    //
    if (n.name () == "treasure" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< treasure_type > r (
        treasure_traits::create (i, f, this));

      if (!this->treasure_)
      {
        this->treasure_.set (r);
        continue;
      }
    }

    break;
  }

  if (!openings_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "openings",
      "");
  }

  if (!pin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pin",
      "");
  }
}

cardType* cardType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cardType (*this, f, c);
}

cardType::
~cardType ()
{
}

// boardType
//

boardType::
boardType ()
: ::xml_schema::type (),
  row_ (::xml_schema::flags (), this),
  shiftCard_ (::xml_schema::flags (), this),
  forbidden_ (::xml_schema::flags (), this)
{
}

boardType::
boardType (const shiftCard_type& shiftCard)
: ::xml_schema::type (),
  row_ (::xml_schema::flags (), this),
  shiftCard_ (shiftCard, ::xml_schema::flags (), this),
  forbidden_ (::xml_schema::flags (), this)
{
}

boardType::
boardType (::std::auto_ptr< shiftCard_type >& shiftCard)
: ::xml_schema::type (),
  row_ (::xml_schema::flags (), this),
  shiftCard_ (shiftCard, ::xml_schema::flags (), this),
  forbidden_ (::xml_schema::flags (), this)
{
}

boardType::
boardType (const boardType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  row_ (x.row_, f, this),
  shiftCard_ (x.shiftCard_, f, this),
  forbidden_ (x.forbidden_, f, this)
{
}

boardType::
boardType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  row_ (f, this),
  shiftCard_ (f, this),
  forbidden_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void boardType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // row
    //
    if (n.name () == "row" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< row_type > r (
        row_traits::create (i, f, this));

      this->row_.push_back (r);
      continue;
    }

    // shiftCard
    //
    if (n.name () == "shiftCard" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shiftCard_type > r (
        shiftCard_traits::create (i, f, this));

      if (!shiftCard_.present ())
      {
        this->shiftCard_.set (r);
        continue;
      }
    }

    // forbidden
    //
    if (n.name () == "forbidden" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< forbidden_type > r (
        forbidden_traits::create (i, f, this));

      if (!this->forbidden_)
      {
        this->forbidden_.set (r);
        continue;
      }
    }

    break;
  }

  if (!shiftCard_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shiftCard",
      "");
  }
}

boardType* boardType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boardType (*this, f, c);
}

boardType::
~boardType ()
{
}

// positionType
//

positionType::
positionType ()
: ::xml_schema::type (),
  row_ (::xml_schema::flags (), this),
  col_ (::xml_schema::flags (), this)
{
}

positionType::
positionType (const row_type& row,
              const col_type& col)
: ::xml_schema::type (),
  row_ (row, ::xml_schema::flags (), this),
  col_ (col, ::xml_schema::flags (), this)
{
}

positionType::
positionType (const positionType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  row_ (x.row_, f, this),
  col_ (x.col_, f, this)
{
}

positionType::
positionType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  row_ (f, this),
  col_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void positionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // row
    //
    if (n.name () == "row" && n.namespace_ ().empty ())
    {
      if (!row_.present ())
      {
        this->row_.set (row_traits::create (i, f, this));
        continue;
      }
    }

    // col
    //
    if (n.name () == "col" && n.namespace_ ().empty ())
    {
      if (!col_.present ())
      {
        this->col_.set (col_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!row_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "row",
      "");
  }

  if (!col_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "col",
      "");
  }
}

positionType* positionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positionType (*this, f, c);
}

positionType::
~positionType ()
{
}

// LoginMessageType
//

LoginMessageType::
LoginMessageType ()
: ::xml_schema::type (),
  name_ (::xml_schema::flags (), this)
{
}

LoginMessageType::
LoginMessageType (const name_type& name)
: ::xml_schema::type (),
  name_ (name, ::xml_schema::flags (), this)
{
}

LoginMessageType::
LoginMessageType (const LoginMessageType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this)
{
}

LoginMessageType::
LoginMessageType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void LoginMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }
}

LoginMessageType* LoginMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LoginMessageType (*this, f, c);
}

LoginMessageType::
~LoginMessageType ()
{
}

// LoginReplyMessageType
//

LoginReplyMessageType::
LoginReplyMessageType ()
: ::xml_schema::type (),
  newID_ (::xml_schema::flags (), this)
{
}

LoginReplyMessageType::
LoginReplyMessageType (const newID_type& newID)
: ::xml_schema::type (),
  newID_ (newID, ::xml_schema::flags (), this)
{
}

LoginReplyMessageType::
LoginReplyMessageType (const LoginReplyMessageType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  newID_ (x.newID_, f, this)
{
}

LoginReplyMessageType::
LoginReplyMessageType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  newID_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void LoginReplyMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // newID
    //
    if (n.name () == "newID" && n.namespace_ ().empty ())
    {
      if (!newID_.present ())
      {
        this->newID_.set (newID_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!newID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "newID",
      "");
  }
}

LoginReplyMessageType* LoginReplyMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LoginReplyMessageType (*this, f, c);
}

LoginReplyMessageType::
~LoginReplyMessageType ()
{
}

// AwaitMoveMessageType
//

AwaitMoveMessageType::
AwaitMoveMessageType ()
: ::xml_schema::type (),
  board_ (::xml_schema::flags (), this),
  treasuresToGo_ (::xml_schema::flags (), this),
  treasure_ (::xml_schema::flags (), this)
{
}

AwaitMoveMessageType::
AwaitMoveMessageType (const board_type& board,
                      const treasure_type& treasure)
: ::xml_schema::type (),
  board_ (board, ::xml_schema::flags (), this),
  treasuresToGo_ (::xml_schema::flags (), this),
  treasure_ (treasure, ::xml_schema::flags (), this)
{
}

AwaitMoveMessageType::
AwaitMoveMessageType (::std::auto_ptr< board_type >& board,
                      const treasure_type& treasure)
: ::xml_schema::type (),
  board_ (board, ::xml_schema::flags (), this),
  treasuresToGo_ (::xml_schema::flags (), this),
  treasure_ (treasure, ::xml_schema::flags (), this)
{
}

AwaitMoveMessageType::
AwaitMoveMessageType (const AwaitMoveMessageType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  board_ (x.board_, f, this),
  treasuresToGo_ (x.treasuresToGo_, f, this),
  treasure_ (x.treasure_, f, this)
{
}

AwaitMoveMessageType::
AwaitMoveMessageType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  board_ (f, this),
  treasuresToGo_ (f, this),
  treasure_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void AwaitMoveMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // board
    //
    if (n.name () == "board" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< board_type > r (
        board_traits::create (i, f, this));

      if (!board_.present ())
      {
        this->board_.set (r);
        continue;
      }
    }

    // treasuresToGo
    //
    if (n.name () == "treasuresToGo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< treasuresToGo_type > r (
        treasuresToGo_traits::create (i, f, this));

      this->treasuresToGo_.push_back (r);
      continue;
    }

    // treasure
    //
    if (n.name () == "treasure" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< treasure_type > r (
        treasure_traits::create (i, f, this));

      if (!treasure_.present ())
      {
        this->treasure_.set (r);
        continue;
      }
    }

    break;
  }

  if (!board_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "board",
      "");
  }

  if (!treasure_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "treasure",
      "");
  }
}

AwaitMoveMessageType* AwaitMoveMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AwaitMoveMessageType (*this, f, c);
}

AwaitMoveMessageType::
~AwaitMoveMessageType ()
{
}

// TreasuresToGoType
//

TreasuresToGoType::
TreasuresToGoType ()
: ::xml_schema::type (),
  player_ (::xml_schema::flags (), this),
  treasures_ (::xml_schema::flags (), this)
{
}

TreasuresToGoType::
TreasuresToGoType (const player_type& player,
                   const treasures_type& treasures)
: ::xml_schema::type (),
  player_ (player, ::xml_schema::flags (), this),
  treasures_ (treasures, ::xml_schema::flags (), this)
{
}

TreasuresToGoType::
TreasuresToGoType (const TreasuresToGoType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  player_ (x.player_, f, this),
  treasures_ (x.treasures_, f, this)
{
}

TreasuresToGoType::
TreasuresToGoType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  player_ (f, this),
  treasures_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void TreasuresToGoType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // player
    //
    if (n.name () == "player" && n.namespace_ ().empty ())
    {
      if (!player_.present ())
      {
        this->player_.set (player_traits::create (i, f, this));
        continue;
      }
    }

    // treasures
    //
    if (n.name () == "treasures" && n.namespace_ ().empty ())
    {
      if (!treasures_.present ())
      {
        this->treasures_.set (treasures_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!player_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "player",
      "");
  }

  if (!treasures_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "treasures",
      "");
  }
}

TreasuresToGoType* TreasuresToGoType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TreasuresToGoType (*this, f, c);
}

TreasuresToGoType::
~TreasuresToGoType ()
{
}

// MoveMessageType
//

MoveMessageType::
MoveMessageType ()
: ::xml_schema::type (),
  shiftPosition_ (::xml_schema::flags (), this),
  newPinPos_ (::xml_schema::flags (), this),
  shiftCard_ (::xml_schema::flags (), this)
{
}

MoveMessageType::
MoveMessageType (const shiftPosition_type& shiftPosition,
                 const newPinPos_type& newPinPos,
                 const shiftCard_type& shiftCard)
: ::xml_schema::type (),
  shiftPosition_ (shiftPosition, ::xml_schema::flags (), this),
  newPinPos_ (newPinPos, ::xml_schema::flags (), this),
  shiftCard_ (shiftCard, ::xml_schema::flags (), this)
{
}

MoveMessageType::
MoveMessageType (::std::auto_ptr< shiftPosition_type >& shiftPosition,
                 ::std::auto_ptr< newPinPos_type >& newPinPos,
                 ::std::auto_ptr< shiftCard_type >& shiftCard)
: ::xml_schema::type (),
  shiftPosition_ (shiftPosition, ::xml_schema::flags (), this),
  newPinPos_ (newPinPos, ::xml_schema::flags (), this),
  shiftCard_ (shiftCard, ::xml_schema::flags (), this)
{
}

MoveMessageType::
MoveMessageType (const MoveMessageType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  shiftPosition_ (x.shiftPosition_, f, this),
  newPinPos_ (x.newPinPos_, f, this),
  shiftCard_ (x.shiftCard_, f, this)
{
}

MoveMessageType::
MoveMessageType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  shiftPosition_ (f, this),
  newPinPos_ (f, this),
  shiftCard_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void MoveMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // shiftPosition
    //
    if (n.name () == "shiftPosition" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shiftPosition_type > r (
        shiftPosition_traits::create (i, f, this));

      if (!shiftPosition_.present ())
      {
        this->shiftPosition_.set (r);
        continue;
      }
    }

    // newPinPos
    //
    if (n.name () == "newPinPos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< newPinPos_type > r (
        newPinPos_traits::create (i, f, this));

      if (!newPinPos_.present ())
      {
        this->newPinPos_.set (r);
        continue;
      }
    }

    // shiftCard
    //
    if (n.name () == "shiftCard" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shiftCard_type > r (
        shiftCard_traits::create (i, f, this));

      if (!shiftCard_.present ())
      {
        this->shiftCard_.set (r);
        continue;
      }
    }

    break;
  }

  if (!shiftPosition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shiftPosition",
      "");
  }

  if (!newPinPos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "newPinPos",
      "");
  }

  if (!shiftCard_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shiftCard",
      "");
  }
}

MoveMessageType* MoveMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MoveMessageType (*this, f, c);
}

MoveMessageType::
~MoveMessageType ()
{
}

// AcceptMessageType
//

AcceptMessageType::
AcceptMessageType ()
: ::xml_schema::type (),
  accept_ (::xml_schema::flags (), this),
  errorCode_ (::xml_schema::flags (), this)
{
}

AcceptMessageType::
AcceptMessageType (const accept_type& accept,
                   const errorCode_type& errorCode)
: ::xml_schema::type (),
  accept_ (accept, ::xml_schema::flags (), this),
  errorCode_ (errorCode, ::xml_schema::flags (), this)
{
}

AcceptMessageType::
AcceptMessageType (const AcceptMessageType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  accept_ (x.accept_, f, this),
  errorCode_ (x.errorCode_, f, this)
{
}

AcceptMessageType::
AcceptMessageType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  accept_ (f, this),
  errorCode_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void AcceptMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // accept
    //
    if (n.name () == "accept" && n.namespace_ ().empty ())
    {
      if (!accept_.present ())
      {
        this->accept_.set (accept_traits::create (i, f, this));
        continue;
      }
    }

    // errorCode
    //
    if (n.name () == "errorCode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< errorCode_type > r (
        errorCode_traits::create (i, f, this));

      if (!errorCode_.present ())
      {
        this->errorCode_.set (r);
        continue;
      }
    }

    break;
  }

  if (!accept_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "accept",
      "");
  }

  if (!errorCode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "errorCode",
      "");
  }
}

AcceptMessageType* AcceptMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AcceptMessageType (*this, f, c);
}

AcceptMessageType::
~AcceptMessageType ()
{
}

// WinMessageType
//

WinMessageType::
WinMessageType ()
: ::xml_schema::type (),
  board_ (::xml_schema::flags (), this),
  winner_ (::xml_schema::flags (), this)
{
}

WinMessageType::
WinMessageType (const board_type& board,
                const winner_type& winner)
: ::xml_schema::type (),
  board_ (board, ::xml_schema::flags (), this),
  winner_ (winner, ::xml_schema::flags (), this)
{
}

WinMessageType::
WinMessageType (::std::auto_ptr< board_type >& board,
                ::std::auto_ptr< winner_type >& winner)
: ::xml_schema::type (),
  board_ (board, ::xml_schema::flags (), this),
  winner_ (winner, ::xml_schema::flags (), this)
{
}

WinMessageType::
WinMessageType (const WinMessageType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  board_ (x.board_, f, this),
  winner_ (x.winner_, f, this)
{
}

WinMessageType::
WinMessageType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  board_ (f, this),
  winner_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void WinMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // board
    //
    if (n.name () == "board" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< board_type > r (
        board_traits::create (i, f, this));

      if (!board_.present ())
      {
        this->board_.set (r);
        continue;
      }
    }

    // winner
    //
    if (n.name () == "winner" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< winner_type > r (
        winner_traits::create (i, f, this));

      if (!winner_.present ())
      {
        this->winner_.set (r);
        continue;
      }
    }

    break;
  }

  if (!board_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "board",
      "");
  }

  if (!winner_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "winner",
      "");
  }
}

WinMessageType* WinMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class WinMessageType (*this, f, c);
}

WinMessageType::
~WinMessageType ()
{
}

// DisconnectMessageType
//

DisconnectMessageType::
DisconnectMessageType ()
: ::xml_schema::type (),
  name_ (::xml_schema::flags (), this),
  erroCode_ (::xml_schema::flags (), this)
{
}

DisconnectMessageType::
DisconnectMessageType (const name_type& name,
                       const erroCode_type& erroCode)
: ::xml_schema::type (),
  name_ (name, ::xml_schema::flags (), this),
  erroCode_ (erroCode, ::xml_schema::flags (), this)
{
}

DisconnectMessageType::
DisconnectMessageType (const DisconnectMessageType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  erroCode_ (x.erroCode_, f, this)
{
}

DisconnectMessageType::
DisconnectMessageType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  erroCode_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void DisconnectMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // erroCode
    //
    if (n.name () == "erroCode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< erroCode_type > r (
        erroCode_traits::create (i, f, this));

      if (!erroCode_.present ())
      {
        this->erroCode_.set (r);
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!erroCode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "erroCode",
      "");
  }
}

DisconnectMessageType* DisconnectMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DisconnectMessageType (*this, f, c);
}

DisconnectMessageType::
~DisconnectMessageType ()
{
}

// openings
//

openings::
openings ()
: ::xml_schema::type (),
  top_ (::xml_schema::flags (), this),
  bottom_ (::xml_schema::flags (), this),
  left_ (::xml_schema::flags (), this),
  right_ (::xml_schema::flags (), this)
{
}

openings::
openings (const top_type& top,
          const bottom_type& bottom,
          const left_type& left,
          const right_type& right)
: ::xml_schema::type (),
  top_ (top, ::xml_schema::flags (), this),
  bottom_ (bottom, ::xml_schema::flags (), this),
  left_ (left, ::xml_schema::flags (), this),
  right_ (right, ::xml_schema::flags (), this)
{
}

openings::
openings (const openings& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  top_ (x.top_, f, this),
  bottom_ (x.bottom_, f, this),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this)
{
}

openings::
openings (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  top_ (f, this),
  bottom_ (f, this),
  left_ (f, this),
  right_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void openings::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // top
    //
    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      if (!top_.present ())
      {
        this->top_.set (top_traits::create (i, f, this));
        continue;
      }
    }

    // bottom
    //
    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      if (!bottom_.present ())
      {
        this->bottom_.set (bottom_traits::create (i, f, this));
        continue;
      }
    }

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      if (!left_.present ())
      {
        this->left_.set (left_traits::create (i, f, this));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      if (!right_.present ())
      {
        this->right_.set (right_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!top_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "top",
      "");
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottom",
      "");
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }
}

openings* openings::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class openings (*this, f, c);
}

openings::
~openings ()
{
}

// pin
//

pin::
pin ()
: ::xml_schema::type (),
  playerID_ (::xml_schema::flags (), this)
{
}

pin::
pin (const pin& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  playerID_ (x.playerID_, f, this)
{
}

pin::
pin (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  playerID_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void pin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // playerID
    //
    if (n.name () == "playerID" && n.namespace_ ().empty ())
    {
      this->playerID_.push_back (playerID_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

pin* pin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class pin (*this, f, c);
}

pin::
~pin ()
{
}

// row
//

row::
row ()
: ::xml_schema::type (),
  col_ (::xml_schema::flags (), this)
{
}

row::
row (const row& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  col_ (x.col_, f, this)
{
}

row::
row (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  col_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void row::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // col
    //
    if (n.name () == "col" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< col_type > r (
        col_traits::create (i, f, this));

      this->col_.push_back (r);
      continue;
    }

    break;
  }
}

row* row::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class row (*this, f, c);
}

row::
~row ()
{
}

// MazeCom
//

MazeCom::
MazeCom ()
: ::xml_schema::type (),
  LoginMessage_ (::xml_schema::flags (), this),
  LoginReplyMessage_ (::xml_schema::flags (), this),
  AwaitMoveMessage_ (::xml_schema::flags (), this),
  MoveMessage_ (::xml_schema::flags (), this),
  AcceptMessage_ (::xml_schema::flags (), this),
  WinMessage_ (::xml_schema::flags (), this),
  DisconnectMessage_ (::xml_schema::flags (), this),
  mcType_ (::xml_schema::flags (), this),
  id_ (::xml_schema::flags (), this)
{
}

MazeCom::
MazeCom (const mcType_type& mcType,
         const id_type& id)
: ::xml_schema::type (),
  LoginMessage_ (::xml_schema::flags (), this),
  LoginReplyMessage_ (::xml_schema::flags (), this),
  AwaitMoveMessage_ (::xml_schema::flags (), this),
  MoveMessage_ (::xml_schema::flags (), this),
  AcceptMessage_ (::xml_schema::flags (), this),
  WinMessage_ (::xml_schema::flags (), this),
  DisconnectMessage_ (::xml_schema::flags (), this),
  mcType_ (mcType, ::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this)
{
}

MazeCom::
MazeCom (const MazeCom& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LoginMessage_ (x.LoginMessage_, f, this),
  LoginReplyMessage_ (x.LoginReplyMessage_, f, this),
  AwaitMoveMessage_ (x.AwaitMoveMessage_, f, this),
  MoveMessage_ (x.MoveMessage_, f, this),
  AcceptMessage_ (x.AcceptMessage_, f, this),
  WinMessage_ (x.WinMessage_, f, this),
  DisconnectMessage_ (x.DisconnectMessage_, f, this),
  mcType_ (x.mcType_, f, this),
  id_ (x.id_, f, this)
{
}

MazeCom::
MazeCom (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LoginMessage_ (f, this),
  LoginReplyMessage_ (f, this),
  AwaitMoveMessage_ (f, this),
  MoveMessage_ (f, this),
  AcceptMessage_ (f, this),
  WinMessage_ (f, this),
  DisconnectMessage_ (f, this),
  mcType_ (f, this),
  id_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void MazeCom::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LoginMessage
    //
    if (n.name () == "LoginMessage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LoginMessage_type > r (
        LoginMessage_traits::create (i, f, this));

      if (!this->LoginMessage_)
      {
        this->LoginMessage_.set (r);
        continue;
      }
    }

    // LoginReplyMessage
    //
    if (n.name () == "LoginReplyMessage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LoginReplyMessage_type > r (
        LoginReplyMessage_traits::create (i, f, this));

      if (!this->LoginReplyMessage_)
      {
        this->LoginReplyMessage_.set (r);
        continue;
      }
    }

    // AwaitMoveMessage
    //
    if (n.name () == "AwaitMoveMessage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AwaitMoveMessage_type > r (
        AwaitMoveMessage_traits::create (i, f, this));

      if (!this->AwaitMoveMessage_)
      {
        this->AwaitMoveMessage_.set (r);
        continue;
      }
    }

    // MoveMessage
    //
    if (n.name () == "MoveMessage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MoveMessage_type > r (
        MoveMessage_traits::create (i, f, this));

      if (!this->MoveMessage_)
      {
        this->MoveMessage_.set (r);
        continue;
      }
    }

    // AcceptMessage
    //
    if (n.name () == "AcceptMessage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AcceptMessage_type > r (
        AcceptMessage_traits::create (i, f, this));

      if (!this->AcceptMessage_)
      {
        this->AcceptMessage_.set (r);
        continue;
      }
    }

    // WinMessage
    //
    if (n.name () == "WinMessage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< WinMessage_type > r (
        WinMessage_traits::create (i, f, this));

      if (!this->WinMessage_)
      {
        this->WinMessage_.set (r);
        continue;
      }
    }

    // DisconnectMessage
    //
    if (n.name () == "DisconnectMessage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DisconnectMessage_type > r (
        DisconnectMessage_traits::create (i, f, this));

      if (!this->DisconnectMessage_)
      {
        this->DisconnectMessage_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "mcType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mcType_type > r (
        mcType_traits::create (i, f, this));

      this->mcType_.set (r);
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!mcType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mcType",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

MazeCom* MazeCom::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MazeCom (*this, f, c);
}

MazeCom::
~MazeCom ()
{
}

// winner
//

winner::
winner ()
: ::xml_schema::string (),
  id_ (::xml_schema::flags (), this)
{
}

winner::
winner (const id_type& id)
: ::xml_schema::string (),
  id_ (id, ::xml_schema::flags (), this)
{
}

winner::
winner (const char* _xsd_string_base,
        const id_type& id)
: ::xml_schema::string (_xsd_string_base),
  id_ (id, ::xml_schema::flags (), this)
{
}

winner::
winner (const ::std::string& _xsd_string_base,
        const id_type& id)
: ::xml_schema::string (_xsd_string_base),
  id_ (id, ::xml_schema::flags (), this)
{
}

winner::
winner (const ::xml_schema::string& _xsd_string_base,
        const id_type& id)
: ::xml_schema::string (_xsd_string_base),
  id_ (id, ::xml_schema::flags (), this)
{
}

winner::
winner (const winner& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  id_ (x.id_, f, this)
{
}

winner::
winner (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  id_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void winner::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

winner* winner::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class winner (*this, f, c);
}

winner::
~winner ()
{
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, MazeComType::value i)
{
  return o << MazeComType::_xsd_MazeComType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const MazeComType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, treasureType::value i)
{
  return o << treasureType::_xsd_treasureType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const treasureType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, ErrorType::value i)
{
  return o << ErrorType::_xsd_ErrorType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const ErrorType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const cardType& i)
{
  o << ::std::endl << "openings: " << i.openings ();
  o << ::std::endl << "pin: " << i.pin ();
  if (i.treasure ())
  {
    o << ::std::endl << "treasure: " << *i.treasure ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const boardType& i)
{
  for (boardType::row_const_iterator
       b (i.row ().begin ()), e (i.row ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "row: " << *b;
  }

  o << ::std::endl << "shiftCard: " << i.shiftCard ();
  if (i.forbidden ())
  {
    o << ::std::endl << "forbidden: " << *i.forbidden ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const positionType& i)
{
  o << ::std::endl << "row: " << i.row ();
  o << ::std::endl << "col: " << i.col ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const LoginMessageType& i)
{
  o << ::std::endl << "name: " << i.name ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const LoginReplyMessageType& i)
{
  o << ::std::endl << "newID: " << i.newID ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AwaitMoveMessageType& i)
{
  o << ::std::endl << "board: " << i.board ();
  for (AwaitMoveMessageType::treasuresToGo_const_iterator
       b (i.treasuresToGo ().begin ()), e (i.treasuresToGo ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "treasuresToGo: " << *b;
  }

  o << ::std::endl << "treasure: " << i.treasure ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const TreasuresToGoType& i)
{
  o << ::std::endl << "player: " << i.player ();
  o << ::std::endl << "treasures: " << i.treasures ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const MoveMessageType& i)
{
  o << ::std::endl << "shiftPosition: " << i.shiftPosition ();
  o << ::std::endl << "newPinPos: " << i.newPinPos ();
  o << ::std::endl << "shiftCard: " << i.shiftCard ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AcceptMessageType& i)
{
  o << ::std::endl << "accept: " << i.accept ();
  o << ::std::endl << "errorCode: " << i.errorCode ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const WinMessageType& i)
{
  o << ::std::endl << "board: " << i.board ();
  o << ::std::endl << "winner: " << i.winner ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const DisconnectMessageType& i)
{
  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "erroCode: " << i.erroCode ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const openings& i)
{
  o << ::std::endl << "top: " << i.top ();
  o << ::std::endl << "bottom: " << i.bottom ();
  o << ::std::endl << "left: " << i.left ();
  o << ::std::endl << "right: " << i.right ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const pin& i)
{
  for (pin::playerID_const_iterator
       b (i.playerID ().begin ()), e (i.playerID ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "playerID: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const row& i)
{
  for (row::col_const_iterator
       b (i.col ().begin ()), e (i.col ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "col: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const MazeCom& i)
{
  if (i.LoginMessage ())
  {
    o << ::std::endl << "LoginMessage: " << *i.LoginMessage ();
  }

  if (i.LoginReplyMessage ())
  {
    o << ::std::endl << "LoginReplyMessage: " << *i.LoginReplyMessage ();
  }

  if (i.AwaitMoveMessage ())
  {
    o << ::std::endl << "AwaitMoveMessage: " << *i.AwaitMoveMessage ();
  }

  if (i.MoveMessage ())
  {
    o << ::std::endl << "MoveMessage: " << *i.MoveMessage ();
  }

  if (i.AcceptMessage ())
  {
    o << ::std::endl << "AcceptMessage: " << *i.AcceptMessage ();
  }

  if (i.WinMessage ())
  {
    o << ::std::endl << "WinMessage: " << *i.WinMessage ();
  }

  if (i.DisconnectMessage ())
  {
    o << ::std::endl << "DisconnectMessage: " << *i.DisconnectMessage ();
  }

  o << ::std::endl << "mcType: " << i.mcType ();
  o << ::std::endl << "id: " << i.id ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const winner& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "id: " << i.id ();
  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::MazeCom >
MazeCom_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::MazeCom > r (
    ::MazeCom_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::MazeCom > r (
    ::MazeCom_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::MazeCom > r (
    ::MazeCom_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MazeCom_ (isrc, f, p);
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MazeCom_ (isrc, h, f, p);
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MazeCom_ (isrc, h, f, p);
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MazeCom_ (isrc, f, p);
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MazeCom_ (isrc, h, f, p);
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MazeCom_ (isrc, h, f, p);
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::MazeCom > r (
    ::MazeCom_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::MazeCom > r (
    ::MazeCom_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::MazeCom > r (
    ::MazeCom_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::MazeCom > r (
      ::MazeCom_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MazeCom" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MazeCom > r (
      ::xsd::cxx::tree::traits< ::MazeCom, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MazeCom",
    "");
}

::std::auto_ptr< ::MazeCom >
MazeCom_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MazeCom" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MazeCom > r (
      ::xsd::cxx::tree::traits< ::MazeCom, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MazeCom",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const MazeComType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const MazeComType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const MazeComType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const treasureType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const treasureType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const treasureType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ErrorType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ErrorType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ErrorType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const cardType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // openings
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "openings",
        e));

    s << i.openings ();
  }

  // pin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "pin",
        e));

    s << i.pin ();
  }

  // treasure
  //
  if (i.treasure ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasure",
        e));

    s << *i.treasure ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const boardType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // row
  //
  for (boardType::row_const_iterator
       b (i.row ().begin ()), n (i.row ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "row",
        e));

    s << *b;
  }

  // shiftCard
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shiftCard",
        e));

    s << i.shiftCard ();
  }

  // forbidden
  //
  if (i.forbidden ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "forbidden",
        e));

    s << *i.forbidden ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const positionType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // row
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "row",
        e));

    s << i.row ();
  }

  // col
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "col",
        e));

    s << i.col ();
  }
}

void
MazeCom_ (::std::ostream& o,
          const ::MazeCom& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
MazeCom_ (::std::ostream& o,
          const ::MazeCom& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MazeCom_ (::std::ostream& o,
          const ::MazeCom& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MazeCom_ (::xercesc::XMLFormatTarget& t,
          const ::MazeCom& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
MazeCom_ (::xercesc::XMLFormatTarget& t,
          const ::MazeCom& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MazeCom_ (::xercesc::XMLFormatTarget& t,
          const ::MazeCom& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MazeCom_ (::xercesc::DOMDocument& d,
          const ::MazeCom& s,
          ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MazeCom" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MazeCom",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
MazeCom_ (const ::MazeCom& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "MazeCom",
      "",
      m, f));

  ::MazeCom_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const LoginMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const LoginReplyMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // newID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "newID",
        e));

    s << i.newID ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AwaitMoveMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // board
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "board",
        e));

    s << i.board ();
  }

  // treasuresToGo
  //
  for (AwaitMoveMessageType::treasuresToGo_const_iterator
       b (i.treasuresToGo ().begin ()), n (i.treasuresToGo ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasuresToGo",
        e));

    s << *b;
  }

  // treasure
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasure",
        e));

    s << i.treasure ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TreasuresToGoType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // player
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "player",
        e));

    s << i.player ();
  }

  // treasures
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasures",
        e));

    s << i.treasures ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MoveMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // shiftPosition
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shiftPosition",
        e));

    s << i.shiftPosition ();
  }

  // newPinPos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "newPinPos",
        e));

    s << i.newPinPos ();
  }

  // shiftCard
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shiftCard",
        e));

    s << i.shiftCard ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AcceptMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // accept
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "accept",
        e));

    s << i.accept ();
  }

  // errorCode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "errorCode",
        e));

    s << i.errorCode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const WinMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // board
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "board",
        e));

    s << i.board ();
  }

  // winner
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "winner",
        e));

    s << i.winner ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DisconnectMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // erroCode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "erroCode",
        e));

    s << i.erroCode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const openings& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // top
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "top",
        e));

    s << i.top ();
  }

  // bottom
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "bottom",
        e));

    s << i.bottom ();
  }

  // left
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "left",
        e));

    s << i.left ();
  }

  // right
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "right",
        e));

    s << i.right ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const pin& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // playerID
  //
  for (pin::playerID_const_iterator
       b (i.playerID ().begin ()), n (i.playerID ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "playerID",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const row& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // col
  //
  for (row::col_const_iterator
       b (i.col ().begin ()), n (i.col ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "col",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const MazeCom& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // LoginMessage
  //
  if (i.LoginMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LoginMessage",
        e));

    s << *i.LoginMessage ();
  }

  // LoginReplyMessage
  //
  if (i.LoginReplyMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LoginReplyMessage",
        e));

    s << *i.LoginReplyMessage ();
  }

  // AwaitMoveMessage
  //
  if (i.AwaitMoveMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AwaitMoveMessage",
        e));

    s << *i.AwaitMoveMessage ();
  }

  // MoveMessage
  //
  if (i.MoveMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MoveMessage",
        e));

    s << *i.MoveMessage ();
  }

  // AcceptMessage
  //
  if (i.AcceptMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AcceptMessage",
        e));

    s << *i.AcceptMessage ();
  }

  // WinMessage
  //
  if (i.WinMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "WinMessage",
        e));

    s << *i.WinMessage ();
  }

  // DisconnectMessage
  //
  if (i.DisconnectMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DisconnectMessage",
        e));

    s << *i.DisconnectMessage ();
  }

  // mcType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "mcType",
        e));

    a << i.mcType ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const winner& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

